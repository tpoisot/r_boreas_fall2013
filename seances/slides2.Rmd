%  Vectorisation et tests
% Timothée Poisot
%

# Dans l'épisode précédent

1. Comment écrire une fonction
2. L'importance de bien penser à son algorithme

# Solution de l'exercice

On génére N points positionnés *au hasard* dans le rectangle ou les deux cercles sont inscrits

On compte combien de points sont dans au moins un cercle (U) et combien sont dans les deux (D)

L'aire relative de la surface ou les cercles se recouvrent est U/D

Version R: `advanced/seance1_cercles.r`

# Programme de la séance

1. Les tests
2. La vectorisation
3. Dynamiques écologiques neutres

# Les tests

Principe général: **si** une condition, **alors** une instruction (**sinon**, autre chose)

Par exemple

```{}
pour tous les nombres i entre et 10
   si i est pair
      afficher i
   sinon
      afficher i + 1
```

# Les tests

```{r}

pair = function(x) (x%%2) == 0

for(i in c(1:10))
{
   if(pair(i))
   {
      print(i)
   } else {
      print(i+1)
   }
}
```

# Pour faire court en R

```{r}
a = 2
b = ifelse(a<3, 0, 1)
b
```

# Le type booléen

Prend deux valeurs: `vrai` et `faux`

Dans R: `TRUE`, `FALSE`, `T`, `F`, *mais aussi* `1`, `0`  

Par exemple:

```{r}
a = 2
a == 2
a+3 > 3
(a+1 > 3) + 1
```

# Comparaisons: *et* logique

```{r}
TRUE & TRUE
TRUE & FALSE
FALSE & FALSE
```

# Comparaisons: *ou* logique

```{r}
TRUE | TRUE
TRUE | FALSE
FALSE | FALSE
```

# Comparaisons: précédence

```{r}
TRUE | FALSE & TRUE
TRUE | ( FALSE & TRUE )
(TRUE | FALSE) & TRUE
```

# Comparaisons: *ou exclusif*

```{r}
xor(TRUE, FALSE)
xor(FALSE, FALSE)
xor(TRUE, TRUE)
```

# Comparaisons: *non*

```{r}
TRUE
!TRUE
!FALSE
```

# Exercice - programmer le *ou exclusif*

**Rappel**: (prédicat 1 *ou* prédicat 2) *mais pas* (prédicat 1 *et* prédicat 2)

# Exercice - en R

```{r}
ouExcl = function(pr1, pr2) (!(pr1 & pr2))&(pr1 | pr2)
xor(T, F)
ouExcl(T, F)
xor(T, T)
ouExcl(T, T)
```

# Rappel - vecteur

Dans R, un vecteur est un object avec plusieurs éléments, numérotés de `1` à `length(objet)`

On accède à l'élément à la position `i` avec `objet[i]`

# Rappel - matrices

Une matrice a deux dimensions, allant de `1` à `nrow(matrice)` et `ncol(matrice)`

On accède à la ligne `i` par `matrice[i,]`, à la colonne `j` par `matrice[j]`, et à l'élément `i,j` par `matrice[i,j]`

# La vectorisation

```{r}
ve = c(1,2,3,4,5)
ve[1]
ve[c(1,3,4)]
ve <= 2
ve[ve <= 2]
```

# La vectorisation

```{r}
ve = c(1:3)
vpl2 = c()
for(i in c(1:length(ve))) vpl2[i] = ve[i]+2
vpl2

ve+2
```
